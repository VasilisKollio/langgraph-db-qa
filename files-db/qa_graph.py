import os
import sqlite3
import re
from typing import Annotated, TypedDict
from langchain_ollama.llms import OllamaLLM
from langchain_community.utilities import SQLDatabase
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.runnables import RunnablePassthrough
from langchain_ollama import ChatOllama
from langgraph.graph import StateGraph, END
from langchain_core.output_parsers import StrOutputParser
from langchain_core.prompts import PromptTemplate
from langchain_core.runnables import RunnableLambda
from requests import session
from typing import Dict
from pathlib import Path


# session_id = 'f4f1174d-d2da-49a3-a9e6-9af68b261982'
# Set your OpenAI API key
# os.environ["OPENAI_API_KEY"] = "your_openai_api_key"

# Initialize the database
# This example uses the Chinook database, which is a sample database available for SQLite.
base_dir = Path(__file__).resolve().parent

db_path = base_dir / "top_detections.db"

# Optional check
if not db_path.exists():
    raise FileNotFoundError(f"Database not found at {db_path}")

# Connect
db_uri = f"sqlite:///{db_path.as_posix()}"
db = SQLDatabase.from_uri(db_uri)

# Initialize the language model
#llm = ChatOpenAI(model="gpt-4o", temperature=0)
llm = OllamaLLM(model="codegemma:latest", temperature=0.5)

# Define the state for the graph
class State(TypedDict):
    question: str
    session_id: str
    query: str
    result: str
    answer: str

def extract_sql_query(llm_output: str) -> str:
    """
    Extracts the SQL query from the ```sql markdown block.
    """
    # The pattern looks for a ```sql block and captures everything inside it
    match = re.search(r"```sql\n(.*?)\n```", llm_output, re.DOTALL)
    
    if match:
        # If a match is found, return the captured group (the query)
        return match.group(1).strip()
    else:
        # As a fallback, if no markdown block is found, assume the output might
        # be the raw SQL query itself. This makes it more robust.
        # We can also raise an error here if the format is strict.
        return llm_output.strip()

def invoke_the_llm(prompt_value):
    """
    Invokes the language model (LLM) to generate a response based on the given prompt value.

    Parameters:
    prompt_value (StringPromptValue): The input prompt value to be passed to the LLM.
        This object should contain the actual prompt string.

    Returns:
    str: The response generated by the LLM. The response is a plain string.

    Note:
    The .to_string() method is crucial. It converts the StringPromptValue object into the
    plain string the model needs. This method should be called before passing the prompt value
    to the LLM's invoke method.
    """
    return llm.invoke(prompt_value.to_string())
def invoke_the_llm(prompt_value):
    # The .to_string() method is crucial. It converts the
    # StringPromptValue object into the plain string the model needs.
    return llm.invoke(prompt_value.to_string())

# 1. Node to write the SQL query
def write_query(state: State):
    """
    Given a question, generate a SQL query to answer it.
    """
    # Prompt template to generate the SQL query
    template = """You are a SQLite expert. Given an input question, first create a syntactically correct SQLite query to run, then look at the results of the query and return the answer to the input question.
    Unless the user specifies in the question a specific number of examples to obtain, query for at most 100 results using the LIMIT clause as per SQLite. You can order the results to return the most informative data in the database.
    Never query for all columns from a table. You must query only the columns that are needed to answer the question. Wrap each column name in double quotes (") to denote them as delimited identifiers.
    Pay attention to use only the column names you can see in the tables below. Be careful to not query for columns that do not exist. Also, pay attention to which column is in which table.
    Use the following format:

    Question: "Question here"
    SQLQuery: "SQL Query to run"

    Crucially, you MUST filter your query to only include results for the provided session_id.
    This is a strict security requirement. For example: 'WHERE "session_id" = "{session_id}"'.

    Only use the following tables:
    {schema}

    Question: {question}
    Session ID: {session_id}
    """
    prompt = PromptTemplate.from_template(template)

    # Chain to generate the query
    query_chain = (
        RunnablePassthrough.assign(schema=lambda _: db.get_table_info()) ##### Assigns the schema to the state
        | prompt
        | llm
        | StrOutputParser()
        | RunnableLambda(extract_sql_query)
    )

    query = query_chain.invoke({"question": state["question"], "session_id": state["session_id"]})
    print(f"Write Query Node: This is the query I am bout to execute {query}")
    return {"query": query}
'''
# 2. Node to execute the SQL query
def execute_query(state: State):
    """
    Execute the SQL query and return the results.
    """
    result = db.run(state["query"])
    print("\n" + "="*50)
    print("--- DEBUG: Raw Result from execute_query ---")
    print(f"Result Type: {type(result)}")
    print(f"Result Value: {result}")
    print("="*50 + "\n")
    return {"result": result}
'''

# 2. Node to execute the SQL query
def execute_query(state: dict):
    """
    Execute the SQL query using LangChain's SQLDatabase and return both rows and column names.
    """
    query = state["query"].strip()

    # Remove any LLM-generated prefixes like "SQLQuery:"
    if query.startswith("SQLQuery:"):
        query = query.replace("SQLQuery:", "", 1).strip()

    # Remove wrapping quotes if present (e.g. entire query in "")
    if query.startswith('"') and query.endswith('"'):
        query = query[1:-1].strip()
    elif query.startswith("'") and query.endswith("'"):
        query = query[1:-1].strip()
    connection = db._engine.raw_connection()  # Access raw connection from SQLAlchemy
    cursor = connection.cursor()

    try:
        cursor.execute(query)
        rows = cursor.fetchall()
        column_names = [desc[0] for desc in cursor.description]

        print("\n" + "="*50)
        print("--- DEBUG: Raw Result from execute_query ---")
        print(f"Column Names: {column_names}")
        print(f"Rows: {rows}")
        print("="*50 + "\n")

        return {"result": (rows, column_names)}
    finally:
        cursor.close()
        connection.close()

# 3. Node to generate the final answer
def generate_answer(state: State):
    """
    Generate a natural language answer based on the query result.
    """
    # Prompt template to generate the answer
    template = """You are a factual database assistant. Your job is to answer the user's question based ONLY on the raw SQL result provided.
    You must follow these rules strictly:
    1.  Interpret the SQL result, which is a string representation of a Python list of tuples.
    2.  Form a direct, natural language answer to the user's question.
    In the SQL response you can expect the following values for some columns: 
    1. The vehicles you might encounter can be car, truck, bus or motorcycle.
    2. The color of the vehicle can be any of the well known colors, i.e. red, green, black and many more.
    3. The license plate of the said vehicles is an alphanumeric string.
    Based on the table schema and question, write a natural language response:
    Schema: {schema}
    Question: {question}
    SQL Response: {result}
    """
    prompt = PromptTemplate.from_template(template)

    # Chain to generate the answer
    answer_chain = (
        RunnablePassthrough.assign(schema=lambda _: db.get_table_info())
        | prompt
        | llm
        | StrOutputParser()
    )

    answer = answer_chain.invoke(
        {"question": state["question"], "result": state["result"]}
    )
    return {"answer": answer}

    """
    Create a temporary SQLite database to store the result data.
    """
# 3.5 New node creating a temporary db for result data 
def create_temp_db(state: dict) -> Dict:
    result = state.get("result")

    if not result or not isinstance(result, tuple) or len(result) != 2:
        print("Invalid or empty result format. Expected tuple of (rows, column_names).")
        return {}

    rows, column_names = result
    if not rows:
        print("No rows to insert into temporary database.")
        return {}

    # Setup temporary database
    temp_conn = sqlite3.connect("temp_result.db")
    temp_cursor = temp_conn.cursor()

    # Sanitize and create the schema
    ch_column_names = [col.replace(" ", "_") for col in column_names]
    columns_sql = ', '.join([f'"{col}" TEXT' for col in ch_column_names])
    placeholder_string = ', '.join(['?'] * len(ch_column_names))

    temp_cursor.execute("DROP TABLE IF EXISTS filtered_results")
    temp_cursor.execute(f"CREATE TABLE filtered_results ({columns_sql})")

    # Insert data
    temp_cursor.executemany(f"INSERT INTO filtered_results VALUES ({placeholder_string})", rows)

    temp_conn.commit()
    temp_conn.close()

    print("Temporary database created successfully.")
    return {}

    # TODO: Implement this function to create a temporary SQLite database
    # and return its name.

# Build the graph
workflow = StateGraph(State)

# Add the nodes
workflow.add_node("write_query", write_query)
workflow.add_node("execute_query", execute_query)
workflow.add_node("generate_answer", generate_answer)
workflow.add_node("create_temp_db", create_temp_db)


# Set the entry point
workflow.set_entry_point("write_query")

# Add the edges

workflow.add_edge("write_query", "execute_query")
workflow.add_edge("execute_query", "create_temp_db")
#workflow.add_edge("execute_query", END)
workflow.add_edge("create_temp_db", "generate_answer")
#workflow.add_edge("execute_query", "generate_answer")
workflow.add_edge("generate_answer", END)

# Compile the graph
sql_qa_graph = workflow.compile()

def get_valid_session_id():
    conn = sqlite3.connect("top_detections.db")  # Use your actual DB path
    cursor = conn.cursor()
    cursor.execute("SELECT DISTINCT session_id FROM top_detections LIMIT 1")
    result = cursor.fetchone()
    conn.close()
    return result[0] if result else None


def interactive_qa():
    print("Interactive System. Type 'exit' to quit.")

    while True:
        question = input("\nAsk a question: ")  # <-- Terminal input
        if question.lower() == "exit":
            break

        session_id = get_valid_session_id()
        if not session_id:
            print("No valid session ID found.")
            continue    

        # Create the initial state with the user's question
        state = {'question': question,
                 'session_id': session_id
                }
        
        # Stream responses from the graph
        for event in sql_qa_graph.stream(state, stream_mode='values'):
            answer = event.get('answer', '')
            if answer:
                print("\nAnswer:")
                print(answer)


        print("\n--- End of response ---")

interactive_qa()  # <-- This line actually starts the terminal interface


    